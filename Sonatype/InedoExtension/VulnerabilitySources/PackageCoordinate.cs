using System;
using System.Diagnostics;
using System.Linq;
using System.Text.RegularExpressions;
using Inedo.Extensibility.VulnerabilitySources;
using Inedo.Feeds;

namespace Inedo.Extensions.Sonatype.VulnerabilitySources
{
    internal sealed class PackageCoordinate
    {
        private static readonly LazyRegex VersionRangePattern = new LazyRegex(@"([\[\(])([^,\[\(\]\)]*)(?:,([^,\[\(\]\)]*))?([\]\)])(?:,|$)", RegexOptions.Compiled);

        internal IVulnerabilityPackage Package { get; }
        public string Type { get; }
        public string Group { get; }
        public string Name { get; }
        public VulnerabilityPackageVersionRange Versions { get; }

        private PackageCoordinate(IVulnerabilityPackage package, string type, string group, string name, VulnerabilityPackageVersionRange versions = default(VulnerabilityPackageVersionRange))
        {
            this.Package = package;
            this.Type = type;
            this.Group = AH.NullIf(group, string.Empty);
            this.Name = name;
            this.Versions = versions;
        }

        internal static string EncodeVersionRange(VulnerabilityPackageVersionRange versions)
        {
            var s = versions.ToString();
            if (string.Equals(s, "(any)", StringComparison.OrdinalIgnoreCase))
            {
                return "(,)";
            }

            return string.Join(",", from p in s.Split(',')
                                   where !string.IsNullOrWhiteSpace(p)
                                   let parts = p.Trim().Split(' ')
                                   select parts.Length == 1 ? EncodeOnePartRange(parts[0]) : EncodeTwoPartRange(parts[0], parts[1]));
        }

        private static string EncodeOnePartRange(string part)
        {
            if (part.StartsWith("<="))
                return "(," + part.Substring(2) + "]";
            if (part.StartsWith(">="))
                return "[" + part.Substring(2) + ",)";
            if (part.StartsWith("<"))
                return "(," + part.Substring(1) + ")";
            if (part.StartsWith(">"))
                return "(" + part.Substring(1) + ",)";
            return "[" + part + "]";
        }

        private static string EncodeTwoPartRange(string min, string max)
        {
            Debug.Assert(min[0] == '>', "invalid minimum version: " + min);
            Debug.Assert(max[0] == '<', "invalid maximum version: " + max);
            return $"{(min[1] == '=' ? '[' : '(')}{min.Substring(1).TrimStart('=')},{max.Substring(1).TrimStart('=')}{(max[1] == '=' ? ']' : ')')}";
        }

        internal static VulnerabilityPackageVersionRange DecodeVersonRange(string versions)
        {
            if (string.IsNullOrEmpty(versions))
            {
                // Temporary until the OSS Index API is updated to include version ranges.
                return VulnerabilityPackageVersionRange.Any;
            }

            return VulnerabilityPackageVersionRange.Multiple(from Match m in VersionRangePattern.Matches(versions)
                                                             select m.Groups[1].Value == "[" && m.Groups[4].Value == "]" && !string.IsNullOrEmpty(m.Groups[2].Value) && string.IsNullOrEmpty(m.Groups[3].Value) ?
                                                             new VulnerabilityPackageVersionRange(m.Groups[2].Value) :
                                                             VulnerabilityPackageVersionRange.Range(
                                                                 AH.NullIf(m.Groups[2].Value, string.Empty),
                                                                 m.Groups[1].Value == "(",
                                                                 AH.NullIf(m.Groups[3].Value, string.Empty),
                                                                 m.Groups[4].Value == ")"
                                                             ));
        }

        public override string ToString() => $"{this.Type}:{AH.ConcatNE(this.Group, "/")}{this.Name}@{EncodeVersionRange(this.Versions)}";

        internal static PackageCoordinate TryCreate(IVulnerabilityPackage package)
        {
            switch (package.FeedType)
            {
                case FeedType.Bower:
                    return new PackageCoordinate(package, "bower", null, package.Name);
                case FeedType.Chocolatey:
                    return new PackageCoordinate(package, "chocolatey", null, package.Name);
                case FeedType.Deployment:
                case FeedType.NuGet:
                case FeedType.PowerShell:
                    return new PackageCoordinate(package, "nuget", null, package.Name);
                case FeedType.Maven:
                    return new PackageCoordinate(package, "maven", package.Group, package.Name);
                case FeedType.Npm:
                    return new PackageCoordinate(package, "npm", package.Group, package.Name);
                case FeedType.RubyGems:
                    return new PackageCoordinate(package, "gem", null, package.Name);
                case FeedType.Asset:
                    // Asset feeds do not support vulnerablity sources.
                    return null;
                case FeedType.Docker:
                    // Docker is not supported by the OSS Index.
                    return null;
                case FeedType.ProGet:
                case FeedType.Romp:
                    // UPack is not supported by the OSS Index.
                    return null;
                case FeedType.Vsix:
                    // VSIX is not supported by the OSS Index.
                    return null;
#if false
                case FeedType.Debian:
                    // .deb is not supported by the OSS Index.
                    return null;
                case FeedType.Python:
                    return new PackageCoordinate(package, "pypi", null, package.Name);
#endif
            }
            return null;
        }
    }
}
