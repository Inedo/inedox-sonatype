using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.IO;
using System.Linq;
using System.Net;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Security;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using System.Web;
using Inedo.Diagnostics;
using Inedo.Documentation;
using Inedo.Extensibility.VulnerabilitySources;
using Inedo.Feeds;
using Inedo.IO;
using Inedo.Serialization;
using Newtonsoft.Json;

namespace Inedo.Extensions.Sonatype.VulnerabilitySources
{
    [DisplayName("OSS Index")]
    [Description("Automatically imports vulnerability information from OSS Index, previously known as Vör Security.")]
    [PersistFrom("Inedo.ProGet.Extensions.VorSecurity.VulnerabilitySources.VorSecurityVulnerabilitySource,VorSecurity")]
    public sealed class OSSIndexVulnerabilitySource : VulnerabilitySource
    {
        private static readonly LazyRegex CoordinateRegex = new LazyRegex(@"^pkg:(?<1>[^/]+)/(?<2>[^@]+)@(?<3>.+)$", RegexOptions.Compiled | RegexOptions.ExplicitCapture);
        private const int MaxCoordinateRequestCount = 128;

        [Persistent]
        [DisplayName("Email address")]
        [PlaceholderText("anonymous")]
        public string UserName { get; set; }
        [DisplayName("API key")]
        [Persistent(Encrypted = true)]
        public SecureString ApiKey { get; set; }
        [Persistent]
        [DisplayName("Verbose log")]
        [Description("Lists every package version that is queried. Significantly increases the length of the execution log.")]
        public bool VerboseLog { get; set; }


        public override async Task<IEnumerable<VulnerabilityInfo>> GetVulnerabilitiesAsync(IVulnerabilitySourceContext context)
        {
            if (context == null)
                throw new ArgumentNullException(nameof(context));
            
            var serializer = new JsonSerializer();

            var receivedVulnerabilities = new Dictionary<string, OSSVulnerability>();

            foreach (var chunk in GetCoordinateChunks(context.Packages))
            {
                int retries = 0;
            Retry:
                try
                {
                    var client = this.GetHttpClient("https://ossindex.sonatype.org/api/v3/component-report");
                    client.Method = "POST";
                    using var request = client.GetRequestStreamAsync().GetAwaiter().GetResult();
                    getChunkContent(request, chunk);
                    using var response = client.GetResponse();                       
                    using (var responseStream = new BufferedStream(response.GetResponseStream()))
                    using (var textReader = new StreamReader(responseStream, InedoLib.UTF8Encoding))
                    using (var jsonTextReader = new JsonTextReader(textReader))
                    {
                        var pvs = serializer.Deserialize<IEnumerable<PackageVulnerabilities>>(jsonTextReader);
                        this.LogDebug($"Request returned {pvs.Count()} vulnerability records.");

                        foreach (var pv in pvs)
                        {
                            var match = CoordinateRegex.Match(pv.Coordinates);
                            if (!match.Success)
                            {
                                this.LogWarning($"Unable to parse returned package coordinate string '{pv.Coordinates}'");
                                continue;
                            }

                            var feedType = ParseFeedType(match.Groups[1].Value);
                            if (feedType == null)
                            {
                                this.LogWarning($"Unable to determine feed type for returned package coordinate string '{pv.Coordinates}'");
                                continue;
                            }

                            var packageName = Uri.UnescapeDataString(match.Groups[2].Value);
                            var packageVersion = match.Groups[3].Value;

                            foreach (var v in pv.Vulnerabilities)
                            {
                                if (!receivedVulnerabilities.TryGetValue(v.Id, out var vulnerability))
                                {
                                    vulnerability = new OSSVulnerability(v.Id, v.Title, v.Description, v.CVSSScore, v.Reference);
                                    receivedVulnerabilities.Add(v.Id, vulnerability);
                                }

                                vulnerability.AddPackageVersion(feedType.Value, packageName, packageVersion);
                            }
                        }
                    }                  

                }
                catch(WebException ex) when ((int)(ex.Response as HttpWebResponse)?.StatusCode == 429)
                {
                    if (retries < 5)
                    {
                        this.LogWarning($"Detected rate limiting. Waiting five minutes before retrying. Attempt {(retries + 1)} of 5.");
                        await Task.Delay(TimeSpan.FromMinutes(5));
                        retries++;
                        goto Retry;
                    }
                    else if (ex.Response is HttpWebResponse httpResponse)
                    {
                        this.LogError("OSS Index returned failure error code: " + (int)httpResponse.StatusCode);
                        using var textReader = new StreamReader(new BufferedStream(new DisposingStream(httpResponse.GetResponseStream(), httpResponse), 64 * 1024), InedoLib.UTF8Encoding);
                        this.LogDebug("Content of response: " + (await textReader.ReadToEndAsync()));
                    }
                    return null;
                }
                catch (WebException ex)
                {
                    if (ex.Response is HttpWebResponse httpResponse) {
                        this.LogError("OSS Index returned failure error code: " + (int)httpResponse.StatusCode);
                        using var textReader = new StreamReader(new BufferedStream(new DisposingStream(httpResponse.GetResponseStream(), httpResponse), 64 * 1024), InedoLib.UTF8Encoding);
                        this.LogDebug("Content of response: " + (await textReader.ReadToEndAsync()));
                    }
                    return null;
                    
                }
            }

            return receivedVulnerabilities
                .Values
                .SelectMany(v => v.GetVulnerabilityInfos());

            void getChunkContent(Stream request, string[] chunk)
            {
                using (var textWriter = new StreamWriter(request, InedoLib.UTF8Encoding, 16, true))
                using (var jsonWriter = new JsonTextWriter(textWriter))
                {
                    jsonWriter.WriteStartObject();
                    jsonWriter.WritePropertyName("coordinates");
                    jsonWriter.WriteStartArray();
                    foreach (var c in chunk)
                        jsonWriter.WriteValue(c);
                    jsonWriter.WriteEndArray();
                    jsonWriter.WriteEndObject();
                }
            }

        }

        private IEnumerable<string[]> GetCoordinateChunks(IEnumerable<IVulnerabilityPackage> packages)
        {
            this.LogInformation($"Attempting to fetch vulnerability info for {packages.Count()} packages ({packages.Sum(p => p.Versions.Count)} distinct package versions)...");

            var list = new List<string>(MaxCoordinateRequestCount);

            int n = 0;
            foreach (var c in getCoordinates())
            {
                if (this.VerboseLog)
                    this.LogDebug($"Adding package coordinate: {c}");

                list.Add(c);
                n++;

                if (n >= MaxCoordinateRequestCount)
                {
                    if (this.VerboseLog)
                        this.LogDebug("Reached maximum coordinates for a request; sending now...");

                    yield return list.ToArray();
                    n = 0;
                    list.Clear();
                }
            }

            if (list.Count > 0)
            {
                if (this.VerboseLog)
                    this.LogDebug($"Sending last {list.Count} coordinates as a final request...");

                yield return list.ToArray();
            }
            else if (this.VerboseLog)
            {
                this.LogDebug("Coordinates were an exact multiple of the request limit; not sending final request.");
            }

            IEnumerable<string> getCoordinates()
            {
                long totalCount = 0;

                foreach (var p in packages)
                {
                    string typeName;
                    switch (p.FeedType)
                    {
                        case FeedType.NuGet:
                        case FeedType.PowerShell:
                        case FeedType.Deployment:
                            typeName = "nuget";
                            break;
                        case FeedType.Chocolatey:
                            typeName = "chocolatey";
                            break;
                        case FeedType.Npm:
                            typeName = "npm";
                            break;
                        case FeedType.Bower:
                            typeName = "bower";
                            break;
                        case FeedType.Maven:
                            typeName = "maven";
                            break;
                        case FeedType.RubyGems:
                            typeName = "gem";
                            break;
                        case FeedType.Pypi:
                            typeName = "pypi";
                            break;
                        default:
                            this.LogDebug($"Skipping package '{AH.ConcatNE(p.Group, "/")}{p.Name}' of unsupported feed type {p.FeedType}");
                            typeName = null;
                            break;
                    }

                    var fullName = p.Name;
                    if (!string.IsNullOrEmpty(p.Group))
                    {
                        if (p.FeedType == FeedType.Npm && !p.Group.StartsWith("@"))
                        {
                            fullName = Uri.EscapeDataString("@" + p.Group) + "/" + fullName;
                        }
                        else
                        {
                            fullName = Uri.EscapeDataString(p.Group) + "/" + fullName;
                        }
                    }

                    if (typeName != null)
                    {
                        foreach (var v in p.Versions)
                        {
                            totalCount++;
                            yield return $"pkg:{typeName}/{fullName}@{v}";
                        }
                    }
                }

                this.LogInformation($"Requested vulnerability information for {totalCount} total package versions.");
            }
        }

        private static FeedType? ParseFeedType(string f)
        {
            switch (f.ToLowerInvariant())
            {
                case "nuget":
                    return FeedType.NuGet;
                case "chocolatey":
                    return FeedType.Chocolatey;
                case "npm":
                    return FeedType.Npm;
                case "bower":
                    return FeedType.Bower;
                case "maven":
                    return FeedType.Maven;
                case "gem":
                    return FeedType.RubyGems;
                case "pypi":
                    return FeedType.Pypi;
                default:
                    return null;
            }
        }

        private WebRequest GetHttpClient(string url)
        {
            var request = WebRequest.CreateHttp(url);
            if (!string.IsNullOrWhiteSpace(this.UserName) && this.ApiKey != null)
            {
                request.Credentials = new NetworkCredential(this.UserName, this.ApiKey);
            }
            request.AllowReadStreamBuffering = false;
            request.Accept = "application/vnd.ossindex.component-report.v1+json";
            request.ContentType = "application/vnd.ossindex.component-report-request.v1+json";
            return request;
        }
    }
}
