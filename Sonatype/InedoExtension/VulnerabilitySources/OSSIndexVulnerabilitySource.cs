using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.IO;
using System.Linq;
using System.Net;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Runtime.CompilerServices;
using System.Security;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Tasks;
using Inedo.Diagnostics;
using Inedo.Documentation;
using Inedo.Extensibility.VulnerabilitySources;
using Inedo.Feeds;
using Inedo.IO;
using Inedo.Serialization;
using Newtonsoft.Json;

namespace Inedo.Extensions.Sonatype.VulnerabilitySources
{
    [DisplayName("OSS Index")]
    [Description("Automatically imports vulnerability information from OSS Index, previously known as Vör Security.")]
    [PersistFrom("Inedo.ProGet.Extensions.VorSecurity.VulnerabilitySources.VorSecurityVulnerabilitySource,VorSecurity")]
    public sealed class OSSIndexVulnerabilitySource : VulnerabilitySource
    {
        private static readonly LazyRegex CoordinateRegex = new LazyRegex(@"^pkg:(?<1>[^/]+)/(?<2>[^@]+)@(?<3>.+)$", RegexOptions.Compiled | RegexOptions.ExplicitCapture);
        private const int MaxCoordinateRequestCount = 128;

        [Persistent]
        [DisplayName("Email address")]
        [PlaceholderText("anonymous")]
        public string UserName { get; set; }
        [DisplayName("API key")]
        [Persistent(Encrypted = true)]
        public SecureString ApiKey { get; set; }
        [Persistent]
        [DisplayName("Verbose log")]
        [Description("Lists every package version that is queried. Significantly increases the length of the execution log.")]
        public bool VerboseLog { get; set; }

        public override async IAsyncEnumerable<VulnerabilityInfo> GetVulnerabilitiesAsync(IVulnerabilitySourceContext context, [EnumeratorCancellation]CancellationToken cancellationToken = default)
        {
            if (context == null)
                throw new ArgumentNullException(nameof(context));
            using (var client = this.GetHttpClient())
            {
                var serializer = new JsonSerializer();

                var receivedVulnerabilities = new Dictionary<string, OSSVulnerability>();

                foreach (var chunk in GetCoordinateChunks(context.Packages))
                {
                    int retries = 0;
                Retry:


                    using (var content = getChunkContent(chunk))
                    using (var response = await client.PostAsync("https://ossindex.sonatype.org/api/v3/component-report", content, cancellationToken))
                    {
                        if ((int)response.StatusCode == 429 && retries < 5)
                        {
                            this.LogWarning($"Detected rate limiting. Waiting five minutes before retrying. Attempt {(retries + 1)} of 5.");
                            await Task.Delay(TimeSpan.FromMinutes(5), cancellationToken);
                            retries++;
                            goto Retry;
                        }

                        if (!response.IsSuccessStatusCode)
                        {
                            this.LogError("OSS Index returned failure error code: " + (int)response.StatusCode);
                            this.LogDebug("Content of response: " + await response.Content.ReadAsStringAsync(cancellationToken));
                            yield break;
                        }
                        using (var responseStream = new BufferedStream(await response.Content.ReadAsStreamAsync(cancellationToken)))
                        using (var textReader = new StreamReader(responseStream, InedoLib.UTF8Encoding))
                        using (var jsonTextReader = new JsonTextReader(textReader))
                        {
                            var pvs = serializer.Deserialize<IEnumerable<PackageVulnerabilities>>(jsonTextReader);
                            this.LogDebug($"Request returned {pvs.Count()} vulnerability records.");

                            foreach (var pv in pvs)
                            {
                                var match = CoordinateRegex.Match(pv.Coordinates);
                                if (!match.Success)
                                {
                                    this.LogWarning($"Unable to parse returned package coordinate string '{pv.Coordinates}'");
                                    continue;
                                }

                                var feedType = ParseFeedType(match.Groups[1].Value);
                                if (feedType == null)
                                {
                                    this.LogWarning($"Unable to determine feed type for returned package coordinate string '{pv.Coordinates}'");
                                    continue;
                                }

                                var packageName = Uri.UnescapeDataString(match.Groups[2].Value);
                                var packageVersion = match.Groups[3].Value;

                                foreach (var v in pv.Vulnerabilities)
                                {
                                    if (!receivedVulnerabilities.TryGetValue(v.Id, out var vulnerability))
                                    {
                                        vulnerability = new OSSVulnerability(v.Id, v.Title, v.Description, v.CVSSScore, v.Reference);
                                        receivedVulnerabilities.Add(v.Id, vulnerability);
                                    }

                                    vulnerability.AddPackageVersion(feedType.Value, packageName, packageVersion);
                                }
                            }
                        }
                    }
                }

                foreach (var vulnInfo in receivedVulnerabilities.Values.SelectMany(v => v.GetVulnerabilityInfos()))
                    yield return vulnInfo;
            }

            HttpContent getChunkContent(string[] chunk)
            {
                var stream = new MemoryStream();
                using (var textWriter = new StreamWriter(stream, InedoLib.UTF8Encoding, 16, true))
                using (var jsonWriter = new JsonTextWriter(textWriter))
                {
                    jsonWriter.WriteStartObject();
                    jsonWriter.WritePropertyName("coordinates");
                    jsonWriter.WriteStartArray();
                    foreach (var c in chunk)
                        jsonWriter.WriteValue(c);
                    jsonWriter.WriteEndArray();
                    jsonWriter.WriteEndObject();
                }

                stream.Position = 0;
                return new StreamContent(stream)
                {
                    Headers =
                    {
                        ContentType = new MediaTypeHeaderValue("application/vnd.ossindex.component-report-request.v1+json")
                    }
                };
            }

        }

        private IEnumerable<string[]> GetCoordinateChunks(IEnumerable<IVulnerabilityPackage> packages)
        {
            this.LogInformation($"Attempting to fetch vulnerability info for {packages.Count()} packages ({packages.Sum(p => p.Versions.Count)} distinct package versions)...");

            var list = new List<string>(MaxCoordinateRequestCount);

            int n = 0;
            foreach (var c in getCoordinates())
            {
                if (this.VerboseLog)
                    this.LogDebug($"Adding package coordinate: {c}");

                list.Add(c);
                n++;

                if (n >= MaxCoordinateRequestCount)
                {
                    if (this.VerboseLog)
                        this.LogDebug("Reached maximum coordinates for a request; sending now...");

                    yield return list.ToArray();
                    n = 0;
                    list.Clear();
                }
            }

            if (list.Count > 0)
            {
                if (this.VerboseLog)
                    this.LogDebug($"Sending last {list.Count} coordinates as a final request...");

                yield return list.ToArray();
            }
            else if (this.VerboseLog)
            {
                this.LogDebug("Coordinates were an exact multiple of the request limit; not sending final request.");
            }

            IEnumerable<string> getCoordinates()
            {
                long totalCount = 0;

                foreach (var p in packages)
                {
                    string typeName;
                    switch (p.FeedType)
                    {
                        case FeedType.NuGet:
                        case FeedType.PowerShell:
                        case FeedType.Deployment:
                            typeName = "nuget";
                            break;
                        case FeedType.Chocolatey:
                            typeName = "chocolatey";
                            break;
                        case FeedType.Npm:
                            typeName = "npm";
                            break;
                        case FeedType.Bower:
                            typeName = "bower";
                            break;
                        case FeedType.Maven:
                            typeName = "maven";
                            break;
                        case FeedType.RubyGems:
                            typeName = "gem";
                            break;
                        case FeedType.Pypi:
                            typeName = "pypi";
                            break;
                        case (FeedType)18:
                            typeName = "conda";
                            break;
                        default:
                            this.LogDebug($"Skipping package '{(string.IsNullOrWhiteSpace(p.Group) ? string.Empty :  $"{p.Group}/")}{p.Name}' of unsupported feed type {p.FeedType}");
                            typeName = null;
                            break;
                    }

                    var fullName = p.Name;
                    if (!string.IsNullOrEmpty(p.Group))
                    {
                        if (p.FeedType == FeedType.Npm && !p.Group.StartsWith("@"))
                        {
                            fullName = Uri.EscapeDataString("@" + p.Group) + "/" + fullName;
                        }
                        else
                        {
                            fullName = Uri.EscapeDataString(p.Group) + "/" + fullName;
                        }
                    }

                    if (typeName != null)
                    {
                        foreach (var v in p.Versions)
                        {
                            totalCount++;
                            yield return $"pkg:{typeName}/{fullName}@{v}";
                        }
                    }
                }

                this.LogInformation($"Requested vulnerability information for {totalCount} total package versions.");
            }
        }

        private static FeedType? ParseFeedType(string f)
        {
            switch (f.ToLowerInvariant())
            {
                case "nuget":
                    return FeedType.NuGet;
                case "chocolatey":
                    return FeedType.Chocolatey;
                case "npm":
                    return FeedType.Npm;
                case "bower":
                    return FeedType.Bower;
                case "maven":
                    return FeedType.Maven;
                case "gem":
                    return FeedType.RubyGems;
                case "pypi":
                    return FeedType.Pypi;
                case "conda":
                    return (FeedType)18;
                default:
                    return null;
            }
        }

        private HttpClient GetHttpClient()
        {
            var client = SDK.CreateHttpClient();
            client.DefaultRequestHeaders.Accept.Add(new MediaTypeWithQualityHeaderValue("application/vnd.ossindex.component-report.v1+json"));
            if (!string.IsNullOrWhiteSpace(this.UserName) && this.ApiKey != null)
            {
                var creds = new NetworkCredential(this.UserName, this.ApiKey);                
                client.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Basic", Base64Encode($"{creds.UserName}:{creds.Password}"));
            }
            return client;
        }

        public static string Base64Encode(string plainText)
        {
            var plainTextBytes = InedoLib.UTF8Encoding.GetBytes(plainText);
            return Convert.ToBase64String(plainTextBytes);
        }
    }
}
