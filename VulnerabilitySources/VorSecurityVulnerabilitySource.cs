using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.IO;
using System.Linq;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Security;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using Inedo.Diagnostics;
using Inedo.Documentation;
using Inedo.IO;
using Inedo.ProGet.Extensibility.VulnerabilitySources;
using Inedo.ProGet.Feeds;
using Inedo.Serialization;
using Newtonsoft.Json;

namespace Inedo.ProGet.Extensions.VorSecurity.VulnerabilitySources
{
    [DisplayName("Vör Security")]
    [Description("Automatically imports vulnerability information from Vör Security.")]
    public sealed class VorSecurityVulnerabilitySource : VulnerabilitySource
    {
        [Required]
        [Persistent]
        [DisplayName("Email address")]
        public string UserName { get; set; }
        [Required]
        [DisplayName("API key")]
        [Persistent(Encrypted = true)]
        public SecureString ApiKey { get; set; }

        public override async Task<IEnumerable<VulnerabilityInfo>> GetVulnerabilitiesAsync(IVulnerabilitySourceContext context)
        {
            if (context == null)
                throw new ArgumentNullException(nameof(context));

            var status = await this.RequestReportAsync(context).ConfigureAwait(false);
            this.LogStatus(status);

            while (status.status == ReportStatus.Pending || status.status == ReportStatus.Running)
            {
                await Task.Delay(5000).ConfigureAwait(false);

                var newStatus = await this.GetReportStatusAsync(status.id).ConfigureAwait(false);
                this.LogStatus(newStatus, status);
                status = newStatus;
            }

            if (status.status == ReportStatus.Finished)
            {
                this.LogInformation("Requesting report...");
                var packages = await this.GetReportAsync(status.id).ConfigureAwait(false);
                this.LogInformation($"Report receieved (packages: {packages.Length}).");
                return EnumerateVulnerabilities(packages);
            }

            if (status.status == ReportStatus.Error)
            {
                this.LogError("Report generation failed.");
                return null;
            }

            this.LogError("Unexpected status received.");
            return null;
        }

        private static IEnumerable<VulnerabilityInfo> EnumerateVulnerabilities(VorPackage[] packages)
        {
            foreach (var p in packages)
            {
                if (p.vulnerabilities != null)
                {
                    foreach (var v in p.vulnerabilities)
                        yield return new VorVulnerabilityInfo(p, v);
                }
            }
        }
        private async Task<VorPackage[]> GetReportAsync(string id)
        {
            var client = new HttpClient();
            client.DefaultRequestHeaders.TryAddWithoutValidation("Authorization", this.UserName + ":" + AH.Unprotect(this.ApiKey));

            using (var response = await client.GetAsync("https://vorsecurity.com/92614235v2.0/report/" + id).ConfigureAwait(false))
            {
                response.EnsureSuccessStatusCode();

                if (!string.Equals(response.Content.Headers.ContentType?.MediaType, "application/json", StringComparison.OrdinalIgnoreCase))
                    throw new InvalidDataException($"Response Content-Type was {response.Content.Headers.ContentType?.MediaType} (expected application/json).");

                using (var jsonReader = new JsonTextReader(new StreamReader(await response.Content.ReadAsStreamAsync().ConfigureAwait(false), InedoLib.UTF8Encoding)))
                {
                    return new JsonSerializer().Deserialize<VorPackage[]>(jsonReader);
                }
            }
        }
        private void LogStatus(ReportStatus status, ReportStatus oldStatus = null)
        {
            // do not log if status has not changed
            if (status.status == oldStatus?.status && status.statusText == oldStatus?.statusText)
                return;

            switch (status.status)
            {
                case ReportStatus.Finished:
                    this.LogInformation("Report status is finished: " + status.statusText);
                    break;

                case ReportStatus.Error:
                    this.LogError("Report status is error: " + status.statusText);
                    break;

                default:
                case ReportStatus.Pending:
                case ReportStatus.Running:
                    this.LogDebug($"Report status is {status.status}: {status.statusText}");
                    break;
            }
        }
        private async Task<ReportStatus> GetReportStatusAsync(string id)
        {
            var client = new HttpClient();
            client.DefaultRequestHeaders.TryAddWithoutValidation("Authorization", this.UserName + ":" + AH.Unprotect(this.ApiKey));

            using (var response = await client.GetAsync("https://vorsecurity.com/92614235v2.0/status/" + id).ConfigureAwait(false))
            {
                return await ProcessReportStatusAsync(response).ConfigureAwait(false);
            }
        }
        private async Task<ReportStatus> RequestReportAsync(IVulnerabilitySourceContext context)
        {
            var client = new HttpClient();
            client.DefaultRequestHeaders.TryAddWithoutValidation("Authorization", this.UserName + ":" + AH.Unprotect(this.ApiKey));

            using (var streamContent = new StreamContent(GetPackageRequestStream(context)))
            {
                streamContent.Headers.ContentType = new MediaTypeHeaderValue("application/json");

                using (var response = await client.PostAsync("https://vorsecurity.com/92614235v2.0/package", streamContent).ConfigureAwait(false))
                {
                    return await ProcessReportStatusAsync(response).ConfigureAwait(false);
                }
            }
        }
        private static async Task<ReportStatus> ProcessReportStatusAsync(HttpResponseMessage response)
        {
            response.EnsureSuccessStatusCode();

            if (!string.Equals(response.Content.Headers.ContentType?.MediaType, "application/json", StringComparison.OrdinalIgnoreCase))
                throw new InvalidDataException($"Response Content-Type was {response.Content.Headers.ContentType?.MediaType} (expected application/json).");

            using (var jsonReader = new JsonTextReader(new StreamReader(await response.Content.ReadAsStreamAsync().ConfigureAwait(false), InedoLib.UTF8Encoding)))
            {
                return new JsonSerializer().Deserialize<ReportStatus>(jsonReader);
            }
        }
        private static Stream GetPackageRequestStream(IVulnerabilitySourceContext context)
        {
            var stream = new SlimMemoryStream();

            using (var textWriter = new StreamWriter(stream, InedoLib.UTF8Encoding, 16, true))
            using (var jsonWriter = new JsonTextWriter(textWriter))
            {
                jsonWriter.WriteStartObject();

                jsonWriter.WritePropertyName("packages");
                jsonWriter.WriteStartArray();

                foreach (var package in context.Packages)
                {
                    jsonWriter.WriteStartObject();

                    jsonWriter.WritePropertyName("pm");
                    jsonWriter.WriteValue(package.FeedType.ToString().ToLowerInvariant());

                    if (package.Group != null)
                    {
                        jsonWriter.WritePropertyName("group");
                        jsonWriter.WriteValue(package.Group);
                    }

                    jsonWriter.WritePropertyName("name");
                    jsonWriter.WriteValue(package.Name);

                    jsonWriter.WriteEndObject();
                }

                jsonWriter.WriteEndArray();

                jsonWriter.WriteEndObject();
            }

            stream.Position = 0;
            return stream;
        }

        private sealed class ReportStatus
        {
            public const string Pending = "pending";
            public const string Running = "running";
            public const string Finished = "finished";
            public const string Error = "error";

            public string id { get; set; }
            public string status { get; set; }
            public string statusText { get; set; }
        }

        private sealed class VorPackage
        {
            [JsonProperty(Required = Required.Always)]
            public long id { get; set; }
            [JsonProperty(Required = Required.Always)]
            public string pm
            {
                get { return this.FeedType.ToString().ToLowerInvariant(); }
                set { this.FeedType = (FeedType)Enum.Parse(typeof(FeedType), value, true); }
            }
            [JsonProperty(Required = Required.Always)]
            public string name { get; set; }
            public VorVulnerability[] vulnerabilities { get; set; }

            [JsonIgnore]
            public FeedType FeedType { get; set; }
        }

        private sealed class VorVulnerability
        {
            private static readonly LazyRegex VersionRegex = new LazyRegex(@"^(?<1>[<>=]*)(?<2>.+)$", RegexOptions.Compiled | RegexOptions.ExplicitCapture);

            [JsonProperty(Required = Required.Always)]
            public long id { get; set; }
            public string title { get; set; }
            public string description { get; set; }
            public string[] versions
            {
                set { this.Versions = ParseVersions(value); }
            }
            public string[] references { get; set; }

            [JsonIgnore]
            public VulnerabilityPackageVersionRange Versions { get; set; }

            private static VulnerabilityPackageVersionRange ParseVersions(string[] versions)
            {
                if (versions == null || versions.Length == 0 || (versions.Length == 1 && string.IsNullOrWhiteSpace(versions[0])))
                    return VulnerabilityPackageVersionRange.Any;

                if (versions.Length == 1)
                    return ParseVersion(versions[0]) ?? VulnerabilityPackageVersionRange.Any;

                return VulnerabilityPackageVersionRange.Multiple(
                    from v in versions
                    let p = ParseVersion(v)
                    where p != null
                    select p.Value
                );
            }
            private static VulnerabilityPackageVersionRange? ParseVersion(string version)
            {
                if (string.IsNullOrWhiteSpace(version))
                    return null;

                var parts = version.Trim().Split(new[] { ' ' }, StringSplitOptions.RemoveEmptyEntries);
                if (parts.Length == 1)
                {
                    var match = VersionRegex.Match(parts[0]);
                    if (!match.Success)
                        return null;

                    var op = match.Groups[1].Value;
                    if (string.IsNullOrEmpty(op))
                        return VulnerabilityPackageVersionRange.Single(parts[0]);

                    var ver = match.Groups[2].Value;
                    switch (op)
                    {
                        case "<":
                            return VulnerabilityPackageVersionRange.Maximum(ver, true);
                        case "<=":
                            return VulnerabilityPackageVersionRange.Maximum(ver, false);
                        case ">":
                            return VulnerabilityPackageVersionRange.Minimum(ver, true);
                        case ">=":
                            return VulnerabilityPackageVersionRange.Maximum(ver, false);
                        default:
                            return null;
                    }
                }
                else if (parts.Length == 2)
                {
                    var match1 = VersionRegex.Match(parts[0]);
                    if (!match1.Success)
                        return null;

                    var op1 = match1.Groups[1].Value;

                    var match2 = VersionRegex.Match(parts[1]);
                    if (!match2.Success)
                        return null;

                    var op2 = match2.Groups[1].Value;

                    if (op1 != ">" && op1 != ">=" && op2 != "<" && op2 != "<=")
                    {
                        Swap(ref op1, ref op2);
                        Swap(ref match1, ref match2);
                    }

                    if ((op1 != ">" && op1 != ">=") || (op2 != "<" && op2 != "<="))
                        return null;

                    return VulnerabilityPackageVersionRange.Range(match1.Groups[2].Value, op1 == ">", match2.Groups[2].Value, op2 == "<");
                }
                else
                {
                    return null;
                }
            }
        }

        private static void Swap<T>(ref T item1, ref T item2)
        {
            var temp = item1;
            item1 = item2;
            item2 = temp;
        }

        private sealed class VorVulnerabilityInfo : VulnerabilityInfo
        {
            private readonly VorPackage package;
            private readonly VorVulnerability vulnerability;

            public VorVulnerabilityInfo(VorPackage package, VorVulnerability vulnerability)
            {
                this.package = package;
                this.vulnerability = vulnerability;
            }

            public override string Id => this.vulnerability.id.ToString();
            public override FeedType FeedType => this.package.FeedType;
            public override string PackageName => this.package.name;
            public override VulnerabilityPackageVersionRange PackageVersions => this.vulnerability.Versions;
            public override string Title => this.vulnerability.title;
            public override string Description => this.vulnerability.description;
        }
    }
}
