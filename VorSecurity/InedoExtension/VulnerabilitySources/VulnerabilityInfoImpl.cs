using System;
using System.Collections.Generic;
using System.Linq;
using Inedo.Extensibility.VulnerabilitySources;
using Inedo.Feeds;
using System.Text.RegularExpressions;

namespace Inedo.ProGet.Extensions.VorSecurity.VulnerabilitySources
{
    public sealed partial class VorSecurityVulnerabilitySource
    {
        private sealed partial class PackageVulnerabilities
        {
            public partial struct Vulnerability
            {
                private sealed class VulnerabilityInfoImpl : VulnerabilityInfo
                {
                    internal VulnerabilityInfoImpl(Vulnerability data, PackageId package)
                    {
                        this.Id = data.CVE;
                        this.FeedType = package.Package.FeedType;
                        this.PackageName = package.Package.Name;
                        this.PackageVersions = ParseVersions(data.Versions);
                        this.Title = data.Title;
                        this.Description = $"{data.Description}\n\n{string.Join("\n", data.IDs.Select(id => $"{id.Key}: {id.Value}"))}\nPublished: {data.PublishedDate}\nUpdated: {data.UpdatedDate}\n\nReferences:\n{string.Join("\n", data.References)}";
                    }

                    public override string Id { get; }
                    public override FeedType FeedType { get; }
                    public override string PackageName { get; }
                    public override VulnerabilityPackageVersionRange PackageVersions { get; }
                    public override string Title { get; }
                    public override string Description { get; }

                    private static readonly LazyRegex VersionRegex = new LazyRegex(@"^(?<1>[<>=]*)(?<2>.+)$", RegexOptions.Compiled | RegexOptions.ExplicitCapture);

                    private static VulnerabilityPackageVersionRange ParseVersions(IReadOnlyList<string> versions)
                    {
                        if (versions == null || versions.Count == 0 || (versions.Count == 1 && string.IsNullOrWhiteSpace(versions[0])))
                            return VulnerabilityPackageVersionRange.Any;

                        if (versions.Count == 1)
                            return ParseVersion(versions[0]) ?? VulnerabilityPackageVersionRange.Any;

                        return VulnerabilityPackageVersionRange.Multiple(
                            from v in versions
                            let p = ParseVersion(v)
                            where p != null
                            select p.Value
                        );
                    }
                    private static VulnerabilityPackageVersionRange? ParseVersion(string version)
                    {
                        if (string.IsNullOrWhiteSpace(version))
                            return null;

                        var parts = version.Trim().Split(new[] { ' ' }, StringSplitOptions.RemoveEmptyEntries);
                        if (parts.Length == 1)
                        {
                            var match = VersionRegex.Match(parts[0]);
                            if (!match.Success)
                                return null;

                            var op = match.Groups[1].Value;
                            if (string.IsNullOrEmpty(op))
                                return VulnerabilityPackageVersionRange.Single(parts[0]);

                            var ver = match.Groups[2].Value;
                            switch (op)
                            {
                                case "<":
                                    return VulnerabilityPackageVersionRange.Maximum(ver, true);
                                case "<=":
                                    return VulnerabilityPackageVersionRange.Maximum(ver, false);
                                case ">":
                                    return VulnerabilityPackageVersionRange.Minimum(ver, true);
                                case ">=":
                                    return VulnerabilityPackageVersionRange.Maximum(ver, false);
                                default:
                                    return null;
                            }
                        }
                        else if (parts.Length == 2)
                        {
                            var match1 = VersionRegex.Match(parts[0]);
                            if (!match1.Success)
                                return null;

                            var op1 = match1.Groups[1].Value;

                            var match2 = VersionRegex.Match(parts[1]);
                            if (!match2.Success)
                                return null;

                            var op2 = match2.Groups[1].Value;

                            if (op1 != ">" && op1 != ">=" && op2 != "<" && op2 != "<=")
                            {
                                Swap(ref op1, ref op2);
                                Swap(ref match1, ref match2);
                            }

                            if ((op1 != ">" && op1 != ">=") || (op2 != "<" && op2 != "<="))
                                return null;

                            return VulnerabilityPackageVersionRange.Range(match1.Groups[2].Value, op1 == ">", match2.Groups[2].Value, op2 == "<");
                        }
                        else
                        {
                            return null;
                        }
                    }
                    private static void Swap<T>(ref T item1, ref T item2)
                    {
                        var temp = item1;
                        item1 = item2;
                        item2 = temp;
                    }
                }
            }
        }
    }
}
